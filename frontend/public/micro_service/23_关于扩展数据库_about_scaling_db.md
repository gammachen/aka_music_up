# 数据库扩容策略

## 数据库拆分概述

随着流量的增加，数据库的压力也会随之而来，一般会伴随着应用拆分进行数据库拆分。按照业务维度进行垂直拆分，目的是解决多个表之间的IO竞争、单机容量问题等。

> **注意**：拆分后会出现，原来可以进行单库join查询，现在不可以了，需要解决跨库join，还要解决分布式事务等问题。

## 数据库垂直拆分

### 基本原理

垂直拆分是指按照业务将一个大库拆分为多个小库，或将一个大表按照字段拆分为多个小表。

### 实施策略

- **跨库join解决方案**：
  - 通过全局表（在每个数据库中都保存一份）
  - 使用ES搜索等异构数据机制来实现
  
- **宽表拆分**：数据库垂直拆分中还存在一种宽表拆多个小表的场景，不过一般在设计时就会做这件事情。

## 读写分离策略

按照不同业务拆分后，随着流量的增加，像商品这种读多写少的数据库会遇到读瓶颈，此时就需要使用读写分离来解决，将读和写进行拆分。

### 实现方式
- 主库负责写操作
- 从库负责读操作
- 主从之间通过复制保持数据同步

## 分库分表策略

随着流量和数据量的增加，单库单表会遇到容量和磁盘/带宽IO瓶颈，单表会随着数据量增长出现性能瓶颈，此时就需要分库、分表，或者分库分表。

### 水平拆分原理

分库分表是一种水平数据拆分，会按照如ID、用户、时间等维度进行数据拆分，拆分算法可以是：
- 取模
- 哈希
- 区间
- 使用数据路由表等

### 分库分表带来的问题及解决方案

分库分表会导致以下问题：

1. **跨库/跨表join问题**
   - 解决方案：
     - 对所有表进行扫描然后做聚合
     - 生成全局表
     - 进行查询维度的数据异构(如订单库按照查询维度异构出商家订单库、用户订单库)
     - 将数据同步到ES搜索

2. **排序分页问题**
   - 解决方案：
     - 在应用层对多个结果集进行合并后再排序分页
     - 使用ES等搜索引擎统一存储

3. **自增ID问题**
   - 解决方案：
     - 不同表、不同自增步长
     - 分布式ID生成器

4. **分布式事务问题**
   - 解决方案：
     - 事务表
     - 补偿机制(执行/回滚)
     - TCC模式(预占/确认/取消)
     - Sagas模式(拆分事务+补偿机制)

> **设计原则**：业务应尽量设计为最终一致性，而不是强一致性。

## NoSQL解决方案

对于一些特殊数据，我们可以考虑使用NoSQL数据库：

### MongoDB应用场景
- 商品介绍很适合存储在MongoDB集群中
- 适合存储半结构化或非结构化数据

### Redis缓存策略

对于互联网应用，尤其是商品系统，读流量可能是写流量的几十倍，而单个商品的查询会非常多，此时，可以考虑使用Redis进行数据缓存。

#### Redis集群架构
- 部署多个Redis实例
- 通过Twemproxy并使用一致性哈希算法进行分片
- 先通过HaProxy进行Twemproxy的负载均衡
- 然后通过内网域名进行访问

## 特殊场景数据处理

### 购物车数据存储
购物车数据是用户维度数据，我们完全可以全量存储到KV存储中，如使用Redis进行存储。为了数据的安全性，我们采用了双写架构。

### 多集群数据同步

#### 主从复制
最简单的办法是在多个集群间通过主从来解决，不过主从切换比较麻烦，当主从断开后需要全量更新时恢复较慢。

#### 程序双写
##### 同步双写
- 实现逻辑比较简单且切换方便
- 写失败其中一个就都失败
- 性能差，不适合多机房同步写，也不适合同步写多个集群

##### 异步双写
- 首先把变更发布到数据总线(如通过MQ实现)
- 然后订阅数据总线变更，异步写其他集群
- 优点：性能好
- 缺点：异步同步有一定的时延，数据一致性差一些
- 解决方案：考虑使用一致性哈希把用户调度到同一个集群，防止用户刷新多次看到不一样的数据

### 实时价格数据
实时价格类似于购物车架构，因为查询量非常大，我们会通过挂更多的从库来扩展读的能力。

## Redis复制机制说明

Redis使用内存复制缓存区来存放主从之间要同步的数据。当主从断开时间较长时，复制缓冲区达到阈值，此时旧缓存数据会被丢弃，此时断开的主从进行同步时将会全量复制。

> **限制**：Redis没有提供类似于mysqlbinlog的机制。


