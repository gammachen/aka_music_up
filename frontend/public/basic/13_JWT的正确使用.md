**JWT（JSON Web Token）默认实现存在安全风险**，尤其是允许攻击者在令牌头部（Header）中**随意指定签名算法**时，可能导致系统被伪造或绕过验证。以下是通俗易懂的解释：

---

### **1. JWT 的结构回顾**
JWT 由三部分组成（用 `.` 分隔）：
```
Header.Payload.Signature
```
- **Header**：声明令牌类型和签名算法（如 `HS256`、`RS256`）。
- **Payload**：存放实际数据（如用户ID、权限）。
- **Signature**：对前两部分的签名，防止篡改。

---

### **2. 关键安全问题：算法伪造**
#### **场景一：强制使用弱算法（如 `none`）**
- **攻击方式**：  
  攻击者篡改 JWT 的 Header，将算法改为 `none`（无签名），并删除 Signature 部分：
  ```json
  {
    "alg": "none",
    "typ": "JWT"
  }
  ```
  - 如果服务器未严格校验算法，会直接信任这种无签名的令牌，导致**任意伪造身份**。

#### **场景二：RS256 → HS256 算法替换攻击**
- **攻击方式**：  
  - 服务器原本使用 **RS256**（非对称加密，用私钥签名，公钥验证）。  
  - 攻击者将 Header 中的算法改为 **HS256**（对称加密，用密钥签名和验证）。  
  - 如果服务器直接使用 RSA 公钥作为 HMAC 的密钥去验证签名，而攻击者恰好能用公钥生成合法签名（因为公钥是公开的），**令牌会被伪造**。

---

### **3. 为什么会出现这种问题？**
- **宽松的算法校验**：早期某些 JWT 库默认允许客户端指定算法，服务器被动接受。
- **配置错误**：开发者未显式限制可接受的算法列表。

---

### **4. 如何防御？**
#### **(1) 固定算法（强制校验）**
在代码中**显式指定算法**，禁止从 Header 中读取：
```python
# Python 示例（PyJWT 库）
decoded = jwt.decode(token, key="secret", algorithms=["HS256"])  # 只允许 HS256
```

#### **(2) 禁用 `none` 算法**
确保 JWT 库的配置中禁用无签名算法。

#### **(3) 区分密钥类型**
- **RS256**：公钥和私钥严格分离，禁止将公钥用作 HMAC 密钥。
- **HS256**：密钥必须保密，且长度足够（如 ≥256 位）。

#### **(4) 使用现成安全方案**
- 直接使用成熟的身份认证框架（如 Spring Security OAuth2、Passport.js），避免手动实现 JWT 验证。

---

### **5. 其他 JWT 安全隐患**
- **令牌泄露**：JWT 一旦签发，在过期前无法废止（需搭配短期有效期或黑名单机制）。
- **数据透明**：Payload 默认是 Base64 编码的明文，敏感信息需加密。

---

### **总结**
- **JWT 本身是安全的，但实现不当会引入风险**。  
- **关键点**：永远不要信任客户端指定的算法，必须在服务端强制校验算法和密钥！  
- 建议通过安全审计工具（如 `jwt.io` 的调试器）测试你的 JWT 实现是否存在漏洞。