---

### **为什么必须三次握手？——彻底杜绝“网络幽灵”问题**

我们可以用一个更贴近生活的场景来理解这个问题：

---

#### **场景比喻：快递员送货的“三次确认”**

假设你网购了一件商品，快递员需要与你确认收货地址是否正确：

1. **第一次确认（你→快递员）**：  
   你打电话给快递员：“我的地址是A小区1号楼，请送货到这里”（发送SYN）。  
   **潜在问题**：如果电话信号差，快递员没听清，你可能会重复拨打。

2. **第二次确认（快递员→你）**：  
   快递员回复：“好的，地址是A小区1号楼对吗？我记下来了”（SYN+ACK）。  
   **此时隐患**：如果这个回复因网络延迟未及时到达你手中，快递员会认为地址已确认，直接开始送货。

3. **第三次确认（你→快递员）**：  
   你再次回复：“没错，就是A小区1号楼”（ACK）。  
   **最终结果**：双方明确地址正确，快递员开始送货。

---

#### **两次握手的致命缺陷：旧请求的“诈尸”**

假设只有前两次确认（两次握手），会发生什么？  
- **问题根源**：网络中存在“延迟的旧请求”。  
  例如：你第一次打电话说地址是A小区1号楼（SYN1），但电话卡顿未送达。你挂断后重新拨打，正确告知地址是B小区2号楼（SYN2），并顺利完成两次握手。  
  **此时**：旧的SYN1请求突然到达快递员手中，快递员认为这是新请求，回复“确认A小区1号楼”（SYN+ACK1）。  
  - 若没有第三次确认（ACK），快递员会直接向A小区1号楼送货，但实际上你已不需要这个地址。  
  - **结果**：快递员资源浪费（送错地址），你收到错误包裹（无效连接）。

---

#### **技术细节还原：两次握手如何导致无效连接**

1. **客户端首次发起SYN旧请求（因网络延迟未到达）**：  
   - 客户端发送SYN1（seq=100）→ 网络延迟未到达服务端。

2. **客户端超时重传SYN新请求**：  
   - 客户端发送SYN2（seq=200）→ 服务端收到后回复SYN+ACK（seq=500，ack=201）。  
   - 客户端收到后建立连接（seq=201，ack=501），进入通信状态。

3. **延迟的SYN1突然到达服务端**：  
   - 服务端误认为是新请求，回复SYN+ACK（seq=600，ack=101）。  
   - **两次握手下**：服务端认为连接已建立（等待客户端发送数据）。  
   - **三次握手下**：客户端发现这是旧请求（期望的ack应为201，但服务端回复ack=101），直接忽略。  

---

#### **总结：三次握手如何解决问题**

| **步骤**         | **两次握手风险**                                  | **三次握手解决方案**                          |
|------------------|-------------------------------------------------|---------------------------------------------|
| 旧SYN到达服务端   | 服务端误建连接，等待无效通信                     | 客户端拒绝回复ACK，服务端超时后关闭连接         |
| 序列号同步        | 仅客户端序列号被确认，服务端序列号可能被伪造       | 双方序列号均被确认，确保数据顺序可靠           |
| 资源占用          | 服务端为旧连接分配内存等资源，导致泄漏             | 无效连接在第三次ACK缺失时自动释放              |

---

### **实际案例：Web服务器的“僵尸连接”攻击**

- **攻击原理**：黑客伪造大量SYN包发送给服务器，但不完成第三次握手。  
  - 两次握手下：服务器为每个SYN分配资源，最终资源耗尽崩溃。  
  - 三次握手下：服务器仅在收到ACK后才分配资源，通过半连接队列限制攻击影响。  

---

**结论**：三次握手是TCP协议解决网络不可靠性、历史报文干扰的核心机制。它像一道“安全门禁”，确保只有真实、实时的通信请求才能建立连接，彻底杜绝“网络幽灵”的干扰。

