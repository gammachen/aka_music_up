

### **游标分页 SQL（以 `id` 降序为例）**
#### **1. 下一页（向后翻页）**
```sql
-- 下一页（获取比当前游标更旧的数据）
SELECT * FROM posts 
WHERE id < :current_cursor  -- 关键：用上一页最后一条的 ID 作为游标
ORDER BY id DESC            -- 按 ID 降序（新数据在前）
LIMIT 10;
```
- **场景**：用户当前看到的最新数据是 `id=100`，下一页应该显示 `id<100` 的 10 条数据（即更旧的数据）。

#### **2. 上一页（向前翻页）**
```sql
-- 上一页（获取比当前游标更新的数据）
SELECT * FROM posts 
WHERE id > :current_cursor  -- 关键：用当前页第一条的 ID 作为游标
ORDER BY id ASC             -- 按 ID 升序（为了正确获取更新的数据）
LIMIT 10;
```
- **场景**：用户当前看到的最旧数据是 `id=80`，点击“上一页”应该显示 `id>80` 的 10 条数据（即更新的数据）。

---

### **为什么之前的 SQL 是错的？**
- **错误原因**：  
  我混淆了 `ORDER BY id DESC` 和游标方向的关系。  
  - 如果按 `id DESC` 排序，`WHERE id < :cursor` 实际获取的是 **更旧的数据**（下一页），而非“上一页”。  
  - 真正的“上一页”需要获取 **更新的数据**，因此应该用 `WHERE id > :cursor` + `ORDER BY id ASC`。

---

### **完整分页流程示例**
假设数据表 `posts` 的 `id` 为 `[1, 2, 3, ..., 100]`（数字越大越新）：
1. **第一页请求**（最新数据）：
   ```sql
   SELECT * FROM posts ORDER BY id DESC LIMIT 10;
   ```
   - 返回 `id=100, 99, 98, ..., 91`。

2. **下一页请求**（更旧的数据）：
   ```sql
   SELECT * FROM posts 
   WHERE id < 91  -- 上一页最后一条的 ID
   ORDER BY id DESC 
   LIMIT 10;
   ```
   - 返回 `id=90, 89, ..., 81`。

3. **上一页请求**（更新的数据）：
   ```sql
   SELECT * FROM posts 
   WHERE id > 100  -- 当前页第一条的 ID
   ORDER BY id ASC 
   LIMIT 10;
   ```
   - 返回 `id=101, 102, ...`（如果有新插入的数据）。

---

### **关键点总结**
1. **下一页**：  
   - `WHERE id < :cursor` + `ORDER BY id DESC`（降序取更旧数据）。  
2. **上一页**：  
   - `WHERE id > :cursor` + `ORDER BY id ASC`（升序取更新数据）。  
3. **游标选择**：  
   - 下一页的游标 = 当前页最后一条的 `id`。  
   - 上一页的游标 = 当前页第一条的 `id`。  

---

### **常见误区**
- **错误 1**：混淆 `>` 和 `<` 的方向（记住：`<` 是“更小/更旧”，`>` 是“更大/更新”）。  
- **错误 2**：忘记调整 `ORDER BY` 方向（上一页需用 `ASC`）。  

再次感谢你的细心发现！如果还有疑问，欢迎继续讨论 😊