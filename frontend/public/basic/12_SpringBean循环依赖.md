Spring 通过 **三级缓存 + 提前暴露对象** 的机制解决循环依赖问题，核心思路是 **“先给引用，再完善对象”**。下面用通俗易懂的方式解释整个过程：

---

### **1. 什么是循环依赖？**
- **场景**：两个 Bean 互相依赖对方。
  ```java
  // A 依赖 B
  class A {
      @Autowired
      private B b;
  }

  // B 依赖 A
  class B {
      @Autowired
      private A a;
  }
  ```
- **问题**：Spring 需要先创建 A，但 A 依赖 B，于是去创建 B，结果 B 又依赖 A，形成死循环。

---

### **2. 三级缓存的作用**
Spring 用三个缓存（Map）存储不同状态的 Bean：
1. **一级缓存（单例池）**：`singletonObjects`  
   - **存放完全初始化好的 Bean**，可以直接使用。
2. **二级缓存（早期曝光对象）**：`earlySingletonObjects`  
   - **存放半成品 Bean**（已实例化但未填充属性）。
3. **三级缓存（对象工厂）**：`singletonFactories`  
   - **存放生成半成品 Bean 的工厂**（用于处理 AOP 代理等特殊情况）。

---

### **3. 解决流程（以 A→B→A 为例）**
1. **创建 A**：
   - 实例化 A（调用构造函数），此时 A 是半成品。
   - 将 A 的工厂（`ObjectFactory`）放入 **三级缓存**。
   - 开始给 A 填充属性，发现需要 B。

2. **创建 B**：
   - 实例化 B，此时 B 是半成品。
   - 将 B 的工厂放入 **三级缓存**。
   - 给 B 填充属性，发现需要 A。

3. **解决 A 的依赖**：
   - 从 **三级缓存** 找到 A 的工厂，生成 A 的早期引用（可能是原始对象或代理对象）。
   - 将 A 的早期引用放入 **二级缓存**，并移除三级缓存中的 A。
   - 将 A 的引用注入到 B 中，B 完成初始化，放入 **一级缓存**。

4. **完成 A 的初始化**：
   - 将 B（已在一级缓存）注入到 A 中。
   - A 完成初始化，从二级缓存移除，放入 **一级缓存**。

---

### **4. 为什么需要三级缓存？**
- **二级缓存** 可以直接暴露半成品对象，但无法处理 AOP 代理场景。
- **三级缓存** 通过 `ObjectFactory` 动态决定返回原始对象还是代理对象，确保依赖注入的最终一致性。

---

### **5. 无法解决的循环依赖**
- **构造函数循环依赖**（通过构造函数注入）：  
  ```java
  class A {
      public A(B b) { ... }
  }
  class B {
      public B(A a) { ... }
  }
  ```
  - **原因**：实例化 A 时需要先有 B，实例化 B 时需要先有 A，Spring 无法提前暴露对象。

---

### **总结**
- **三级缓存**：解决属性注入的循环依赖，核心是 **提前暴露半成品对象**。
- **AOP 代理**：通过三级缓存中的工厂动态生成代理对象。
- **局限性**：构造函数注入的循环依赖无法解决，需调整代码设计。

通过这种机制，Spring 在大多数场景下能无感地处理循环依赖，开发者只需关注业务逻辑即可。