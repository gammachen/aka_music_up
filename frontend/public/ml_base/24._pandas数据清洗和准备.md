# 数据清洗和准备
在数据分析和建模的过程中，相当多的时间要用在数据准备上：加载、清理、转换以及重塑。这些工作会占到分析师时间的80%或更多。

# 处理缺失数据
* 在许多数据分析工作中，缺失数据是经常发生的。pandas的目标之一就是尽量轻松地处理缺失数据。例如，pandas对象的所有描述性统计默认都不包括缺失数据。

* 
缺失数据在pandas中呈现的方式有些不完美，但对于大多数用户可以保证功能正常。对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据。我们称其为哨兵值，可以方便的检测出来：


```python
import pandas as pd
```


```python
xa=pd.DataFrame(pd.np.random.randn(10,4),index=[chr(i) for i in range(65,75)],columns=[chr(i) for i in range(97,101)])
xa
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>-0.458535</td>
      <td>-0.966027</td>
      <td>1.990720</td>
      <td>0.049643</td>
    </tr>
    <tr>
      <th>B</th>
      <td>-2.019448</td>
      <td>0.469118</td>
      <td>-0.368198</td>
      <td>0.016554</td>
    </tr>
    <tr>
      <th>C</th>
      <td>0.672553</td>
      <td>0.848501</td>
      <td>-0.045076</td>
      <td>-0.637709</td>
    </tr>
    <tr>
      <th>D</th>
      <td>-0.204048</td>
      <td>0.427297</td>
      <td>2.821062</td>
      <td>-3.404246</td>
    </tr>
    <tr>
      <th>E</th>
      <td>0.851437</td>
      <td>0.430311</td>
      <td>-0.234595</td>
      <td>-0.402730</td>
    </tr>
    <tr>
      <th>F</th>
      <td>1.632020</td>
      <td>-0.912922</td>
      <td>0.408945</td>
      <td>0.844415</td>
    </tr>
    <tr>
      <th>G</th>
      <td>-0.998616</td>
      <td>-0.257000</td>
      <td>0.528972</td>
      <td>0.110432</td>
    </tr>
    <tr>
      <th>H</th>
      <td>-0.074171</td>
      <td>-0.352392</td>
      <td>0.203358</td>
      <td>-0.220420</td>
    </tr>
    <tr>
      <th>I</th>
      <td>-0.677709</td>
      <td>0.595538</td>
      <td>-1.613784</td>
      <td>-0.339048</td>
    </tr>
    <tr>
      <th>J</th>
      <td>-0.178358</td>
      <td>-0.594873</td>
      <td>-0.461883</td>
      <td>-1.959267</td>
    </tr>
  </tbody>
</table>
</div>




```python
xb=pd.np.sqrt(xa)
xb
```

    d:\env\pythonve\test36\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: invalid value encountered in sqrt
      """Entry point for launching an IPython kernel.





<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.410929</td>
      <td>0.222806</td>
    </tr>
    <tr>
      <th>B</th>
      <td>NaN</td>
      <td>0.684922</td>
      <td>NaN</td>
      <td>0.128661</td>
    </tr>
    <tr>
      <th>C</th>
      <td>0.820094</td>
      <td>0.921141</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>D</th>
      <td>NaN</td>
      <td>0.653680</td>
      <td>1.679602</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>E</th>
      <td>0.922733</td>
      <td>0.655981</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>F</th>
      <td>1.277505</td>
      <td>NaN</td>
      <td>0.639488</td>
      <td>0.918921</td>
    </tr>
    <tr>
      <th>G</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.727305</td>
      <td>0.332313</td>
    </tr>
    <tr>
      <th>H</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.450952</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>I</th>
      <td>NaN</td>
      <td>0.771711</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>J</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



# isna\isnull 判断无效值


```python
xb.isna()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>B</th>
      <td>True</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
    </tr>
    <tr>
      <th>C</th>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>D</th>
      <td>True</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
    </tr>
    <tr>
      <th>E</th>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>F</th>
      <td>False</td>
      <td>True</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>G</th>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>H</th>
      <td>True</td>
      <td>True</td>
      <td>False</td>
      <td>True</td>
    </tr>
    <tr>
      <th>I</th>
      <td>True</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>J</th>
      <td>True</td>
      <td>True</td>
      <td>True</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
</div>



# dropna 过滤无效值


```python
xb.a=range(10)
```


```python
xb.iloc[0,:]=range(4)
```


```python
xb
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1.000000</td>
      <td>2.000000</td>
      <td>3.000000</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1</td>
      <td>0.684922</td>
      <td>NaN</td>
      <td>0.128661</td>
    </tr>
    <tr>
      <th>C</th>
      <td>2</td>
      <td>0.921141</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>D</th>
      <td>3</td>
      <td>0.653680</td>
      <td>1.679602</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>E</th>
      <td>4</td>
      <td>0.655981</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>F</th>
      <td>5</td>
      <td>NaN</td>
      <td>0.639488</td>
      <td>0.918921</td>
    </tr>
    <tr>
      <th>G</th>
      <td>6</td>
      <td>NaN</td>
      <td>0.727305</td>
      <td>0.332313</td>
    </tr>
    <tr>
      <th>H</th>
      <td>7</td>
      <td>NaN</td>
      <td>0.450952</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>I</th>
      <td>8</td>
      <td>0.771711</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>J</th>
      <td>9</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




```python
xb.dropna(axis='columns',how='any')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1</td>
    </tr>
    <tr>
      <th>C</th>
      <td>2</td>
    </tr>
    <tr>
      <th>D</th>
      <td>3</td>
    </tr>
    <tr>
      <th>E</th>
      <td>4</td>
    </tr>
    <tr>
      <th>F</th>
      <td>5</td>
    </tr>
    <tr>
      <th>G</th>
      <td>6</td>
    </tr>
    <tr>
      <th>H</th>
      <td>7</td>
    </tr>
    <tr>
      <th>I</th>
      <td>8</td>
    </tr>
    <tr>
      <th>J</th>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>




```python
xb.dropna(axis=0,thresh=3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1.000000</td>
      <td>2.000000</td>
      <td>3.000000</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1</td>
      <td>0.684922</td>
      <td>NaN</td>
      <td>0.128661</td>
    </tr>
    <tr>
      <th>D</th>
      <td>3</td>
      <td>0.653680</td>
      <td>1.679602</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>F</th>
      <td>5</td>
      <td>NaN</td>
      <td>0.639488</td>
      <td>0.918921</td>
    </tr>
    <tr>
      <th>G</th>
      <td>6</td>
      <td>NaN</td>
      <td>0.727305</td>
      <td>0.332313</td>
    </tr>
  </tbody>
</table>
</div>



# 填充缺失数据
你可能不想滤除缺失数据（有可能会丢弃跟它有关的其他数据），而是希望通过其他方式填补那些“空洞”。对于大多数情况而言，fillna方法是最主要的函数。通过一个常数调用fillna就会将缺失值替换为那个常数值：


```python
xb.fillna(0)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1.000000</td>
      <td>2.000000</td>
      <td>3.000000</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1</td>
      <td>0.684922</td>
      <td>0.000000</td>
      <td>0.128661</td>
    </tr>
    <tr>
      <th>C</th>
      <td>2</td>
      <td>0.921141</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>D</th>
      <td>3</td>
      <td>0.653680</td>
      <td>1.679602</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>E</th>
      <td>4</td>
      <td>0.655981</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>F</th>
      <td>5</td>
      <td>0.000000</td>
      <td>0.639488</td>
      <td>0.918921</td>
    </tr>
    <tr>
      <th>G</th>
      <td>6</td>
      <td>0.000000</td>
      <td>0.727305</td>
      <td>0.332313</td>
    </tr>
    <tr>
      <th>H</th>
      <td>7</td>
      <td>0.000000</td>
      <td>0.450952</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>I</th>
      <td>8</td>
      <td>0.771711</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>J</th>
      <td>9</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
  </tbody>
</table>
</div>



若是通过一个字典调用fillna，就可以实现对不同的列填充不同的值：


```python
xb.fillna({'b':100,'c':-100,'d':0})
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1.000000</td>
      <td>2.000000</td>
      <td>3.000000</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1</td>
      <td>0.684922</td>
      <td>-100.000000</td>
      <td>0.128661</td>
    </tr>
    <tr>
      <th>C</th>
      <td>2</td>
      <td>0.921141</td>
      <td>-100.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>D</th>
      <td>3</td>
      <td>0.653680</td>
      <td>1.679602</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>E</th>
      <td>4</td>
      <td>0.655981</td>
      <td>-100.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>F</th>
      <td>5</td>
      <td>100.000000</td>
      <td>0.639488</td>
      <td>0.918921</td>
    </tr>
    <tr>
      <th>G</th>
      <td>6</td>
      <td>100.000000</td>
      <td>0.727305</td>
      <td>0.332313</td>
    </tr>
    <tr>
      <th>H</th>
      <td>7</td>
      <td>100.000000</td>
      <td>0.450952</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>I</th>
      <td>8</td>
      <td>0.771711</td>
      <td>-100.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>J</th>
      <td>9</td>
      <td>100.000000</td>
      <td>-100.000000</td>
      <td>0.000000</td>
    </tr>
  </tbody>
</table>
</div>




```python
xb.fillna(method='ffill',axis='columns')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0.0</td>
      <td>1.000000</td>
      <td>2.000000</td>
      <td>3.000000</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1.0</td>
      <td>0.684922</td>
      <td>0.684922</td>
      <td>0.128661</td>
    </tr>
    <tr>
      <th>C</th>
      <td>2.0</td>
      <td>0.921141</td>
      <td>0.921141</td>
      <td>0.921141</td>
    </tr>
    <tr>
      <th>D</th>
      <td>3.0</td>
      <td>0.653680</td>
      <td>1.679602</td>
      <td>1.679602</td>
    </tr>
    <tr>
      <th>E</th>
      <td>4.0</td>
      <td>0.655981</td>
      <td>0.655981</td>
      <td>0.655981</td>
    </tr>
    <tr>
      <th>F</th>
      <td>5.0</td>
      <td>5.000000</td>
      <td>0.639488</td>
      <td>0.918921</td>
    </tr>
    <tr>
      <th>G</th>
      <td>6.0</td>
      <td>6.000000</td>
      <td>0.727305</td>
      <td>0.332313</td>
    </tr>
    <tr>
      <th>H</th>
      <td>7.0</td>
      <td>7.000000</td>
      <td>0.450952</td>
      <td>0.450952</td>
    </tr>
    <tr>
      <th>I</th>
      <td>8.0</td>
      <td>0.771711</td>
      <td>0.771711</td>
      <td>0.771711</td>
    </tr>
    <tr>
      <th>J</th>
      <td>9.0</td>
      <td>9.000000</td>
      <td>9.000000</td>
      <td>9.000000</td>
    </tr>
  </tbody>
</table>
</div>




```python
xb.fillna?
```

# 数据转换\移除重复数据


```python
xa=pd.DataFrame([range(4) if i%2 else range(1,5) for i in range(8)])
xa
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>6</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>



DataFrame的duplicated方法返回一个布尔型Series，表示各行是否是重复行（前面出现过的行）：


```python
xa.duplicated()
```




    0    False
    1    False
    2     True
    3     True
    4     True
    5     True
    6     True
    7     True
    dtype: bool



还有一个与此相关的drop_duplicates方法，它会返回一个DataFrame，重复的数组会标为False：


```python
xa.drop_duplicates()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>



这两个方法默认会判断全部列，你也可以指定部分列进行重复项判断。


```python
xa.drop_duplicates([1])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>



duplicated和drop_duplicates默认保留的是第一个出现的值组合。传入keep='last'则保留最后一个：


```python
xa.drop_duplicates(keep='last')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>6</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>



# 利用函数或映射进行数据转换


```python
xa.applymap(lambda x:str(x**2-1)+"a")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0a</td>
      <td>3a</td>
      <td>8a</td>
      <td>15a</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-1a</td>
      <td>0a</td>
      <td>3a</td>
      <td>8a</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0a</td>
      <td>3a</td>
      <td>8a</td>
      <td>15a</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-1a</td>
      <td>0a</td>
      <td>3a</td>
      <td>8a</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0a</td>
      <td>3a</td>
      <td>8a</td>
      <td>15a</td>
    </tr>
    <tr>
      <th>5</th>
      <td>-1a</td>
      <td>0a</td>
      <td>3a</td>
      <td>8a</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0a</td>
      <td>3a</td>
      <td>8a</td>
      <td>15a</td>
    </tr>
    <tr>
      <th>7</th>
      <td>-1a</td>
      <td>0a</td>
      <td>3a</td>
      <td>8a</td>
    </tr>
  </tbody>
</table>
</div>



# 替换值
利用fillna方法填充缺失数据可以看做值替换的一种特殊情况。前面已经看到，map可用于修改对象的数据子集，而replace则提供了一种实现该功能的更简单、更灵活的方式。我们来看看下面这个Series：


```python
xa[0].replace([0,1],[-100,100])
```




    0    100
    1   -100
    2    100
    3   -100
    4    100
    5   -100
    6    100
    7   -100
    Name: 0, dtype: int64




```python
xa[0].replace({0:100,1:-100})
```




    0   -100
    1    100
    2   -100
    3    100
    4   -100
    5    100
    6   -100
    7    100
    Name: 0, dtype: int64



# 重命名轴索引
跟Series中的值一样，轴标签也可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。轴还可以被就地修改，而无需新建一个数据结构。


```python
xb=xa[0]
```


```python
xb.index=xb.index.map(lambda x:"str:{:.2f}".format(x))
```


```python
xb
```




    str:0.00    1
    str:1.00    0
    str:2.00    1
    str:3.00    0
    str:4.00    1
    str:5.00    0
    str:6.00    1
    str:7.00    0
    Name: 0, dtype: int64



如果想要创建数据集的转换版（而不是修改原始数据），比较实用的方法是rename


```python
xa.rename(index=lambda x:chr(x+80),columns=lambda x:chr(x+100))
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>g</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>P</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>Q</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>R</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>S</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>T</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>U</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>V</th>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>W</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>



# 离散化和面元划分
为了便于分析，连续数据常常被离散化或拆分


```python
xa=pd.Series(range(50))
xb=pd.cut(xa,[-1,10,30,50])
```

是一个特殊的Categorical对象。结果展示了pandas.cut划分的面元。你可以将其看做一组表示面元名称的字符串。


```python
pd.value_counts(xb)
```




    (10, 30]    20
    (30, 50]    19
    (-1, 10]    11
    dtype: int64



# 检测和过滤异常值
过滤或变换异常值（outlier）在很大程度上就是运用数组运算


```python
xa=pd.DataFrame(pd.np.random.randn(100,5))
```


```python
xa.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>100.000000</td>
      <td>100.000000</td>
      <td>100.000000</td>
      <td>100.000000</td>
      <td>100.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.005161</td>
      <td>-0.123360</td>
      <td>0.097801</td>
      <td>0.144553</td>
      <td>-0.018344</td>
    </tr>
    <tr>
      <th>std</th>
      <td>1.038628</td>
      <td>1.049578</td>
      <td>1.018409</td>
      <td>1.027993</td>
      <td>1.055948</td>
    </tr>
    <tr>
      <th>min</th>
      <td>-2.434947</td>
      <td>-2.402733</td>
      <td>-2.177662</td>
      <td>-2.228860</td>
      <td>-2.164555</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>-0.663125</td>
      <td>-0.939597</td>
      <td>-0.598766</td>
      <td>-0.676779</td>
      <td>-0.837292</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>-0.038703</td>
      <td>-0.051882</td>
      <td>0.024745</td>
      <td>0.244455</td>
      <td>-0.229076</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.685943</td>
      <td>0.715446</td>
      <td>0.837162</td>
      <td>0.796220</td>
      <td>0.687940</td>
    </tr>
    <tr>
      <th>max</th>
      <td>3.000000</td>
      <td>2.907048</td>
      <td>2.665410</td>
      <td>2.638246</td>
      <td>3.000000</td>
    </tr>
  </tbody>
</table>
</div>




```python
xb=xa[0]
```


```python
xb[pd.np.abs(xb)>3]=3
```


```python
xa[pd.np.abs(xa)>3]=3
```

# 排列和随机采样
利用numpy.random.permutation函数可以轻松实现对Series或DataFrame的列的排列工作（permuting，随机重排序）。


```python
xa=pd.DataFrame(pd.np.arange(20).reshape((5,4)))
xa
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <th>3</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
    <tr>
      <th>4</th>
      <td>16</td>
      <td>17</td>
      <td>18</td>
      <td>19</td>
    </tr>
  </tbody>
</table>
</div>




```python
perm=pd.np.random.permutation(5)
perm
```




    array([3, 1, 0, 4, 2])




```python
xa.take(perm)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>16</td>
      <td>17</td>
      <td>18</td>
      <td>19</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>




```python
xa.iloc[perm,:]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
    </tr>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>16</td>
      <td>17</td>
      <td>18</td>
      <td>19</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>




```python
xa.sample(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>16</td>
      <td>17</td>
      <td>18</td>
      <td>19</td>
    </tr>
    <tr>
      <th>3</th>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>



# pandas的矢量化字符串函数
* 通过data.map，所有字符串和正则表达式方法都能被应用于（传入lambda表达式或其他函数）各个值，但是如果存在NA（null）就会报错。
* 为了解决这个问题，Series有一些能够跳过NA值的面向数组方法，进行字符串操作。通过Series的str属性即可访问这些方法。


```python
xa=pd.Series([chr(i) for i in range(65,100)])
xa
```




    0     A
    1     B
    2     C
    3     D
    4     E
    5     F
    6     G
    7     H
    8     I
    9     J
    10    K
    11    L
    12    M
    13    N
    14    O
    15    P
    16    Q
    17    R
    18    S
    19    T
    20    U
    21    V
    22    W
    23    X
    24    Y
    25    Z
    26    [
    27    \
    28    ]
    29    ^
    30    _
    31    `
    32    a
    33    b
    34    c
    dtype: object




```python
dir(xa.str)
```




    ['__class__',
     '__delattr__',
     '__dict__',
     '__dir__',
     '__doc__',
     '__eq__',
     '__format__',
     '__frozen',
     '__ge__',
     '__getattribute__',
     '__getitem__',
     '__gt__',
     '__hash__',
     '__init__',
     '__init_subclass__',
     '__iter__',
     '__le__',
     '__lt__',
     '__module__',
     '__ne__',
     '__new__',
     '__reduce__',
     '__reduce_ex__',
     '__repr__',
     '__setattr__',
     '__sizeof__',
     '__str__',
     '__subclasshook__',
     '__weakref__',
     '_data',
     '_freeze',
     '_get_series_list',
     '_is_categorical',
     '_make_accessor',
     '_orig',
     '_validate',
     '_wrap_result',
     'capitalize',
     'cat',
     'center',
     'contains',
     'count',
     'decode',
     'encode',
     'endswith',
     'extract',
     'extractall',
     'find',
     'findall',
     'get',
     'get_dummies',
     'index',
     'isalnum',
     'isalpha',
     'isdecimal',
     'isdigit',
     'islower',
     'isnumeric',
     'isspace',
     'istitle',
     'isupper',
     'join',
     'len',
     'ljust',
     'lower',
     'lstrip',
     'match',
     'normalize',
     'pad',
     'partition',
     'repeat',
     'replace',
     'rfind',
     'rindex',
     'rjust',
     'rpartition',
     'rsplit',
     'rstrip',
     'slice',
     'slice_replace',
     'split',
     'startswith',
     'strip',
     'swapcase',
     'title',
     'translate',
     'upper',
     'wrap',
     'zfill']



高效的数据准备可以让你将更多的时间用于数据分析，花较少的时间用于准备工作，这样就可以极大地提高生产力。
