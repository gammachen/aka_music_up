# 模块
* 模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。

# 引用系统模块


```python
import sys
```


```python
print(sys.path)
```

# 为什么需要__init__.py 
__init__.py文件用于组织包（package）。这里首先需要明确包（package）的概念。什么是包（package）？简单来说，包是含有python模块的文件夹。一个python模块（module）为一个py文件，里面写有函数和类。包（package）是为了更好的管理模块（module）,相当于多个模块的父节点。

当文件夹下有__init__.py时，表示当前文件夹是一个package，其下的多个module统一构成一个整体。这些module都可以通过同一个package引入代码中。

# Pycharm自定义头部模板
* File->settings->Editor->File and Code Templates->Python Script

``` python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@Time    : ${DATE} ${TIME}
@Author  : zichao.li
@Site    : ${SITE}
@File    : ${NAME}
@Software: ${PRODUCT_NAME}
"""

if __name__ == '__main__':
    pass
```

# 执行自定义模块


```python
%run mod/show.py hello lets start quant trade
```


```python
%magic
```

# 引用自定义模块


```python
import mod.show
prt=mod.show.prt
prt(9)
```


```python
mod.show.prt(8)
```

# import 语句
* 想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：
> import module1[, module2[,... moduleN]

* 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。
* 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。
* 当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？
> 这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。
这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。
搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量


```python
import sys
sys.path
```

# from…import 语句
Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：
```
from modname import name1[, name2[, ... nameN]]
```


```python
from mod.show import jiafa,jianfa,prt
```


```python
jiafa(1,2)
```


```python
jianfa(2,4)
```


```python
from mod.show import *
```


```python
type(jiafa)
```




    function



# 深入模块
* 模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。
* 每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。
* 从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。
* 模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。
* 还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。

# \__name\__属性
一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用\__name\__属性来使该程序块仅在该模块自身运行时执行。


```python
from mod import show
```

    hello quant



```python
%run mod/show.py
```

    hello quant
    main program


说明： 每个模块都有一个\__name\__属性，当其值是'\__main\__'时，表明该模块自身在运行，否则是被引入。

# dir() 函数
内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:


```python
dir(show)
```




    ['__builtins__',
     '__cached__',
     '__doc__',
     '__file__',
     '__loader__',
     '__name__',
     '__package__',
     '__spec__',
     'jiafa',
     'jianfa',
     'prt',
     'sys']




```python
dir(sys)
```




    ['__displayhook__',
     '__doc__',
     '__excepthook__',
     '__interactivehook__',
     '__loader__',
     '__name__',
     '__package__',
     '__spec__',
     '__stderr__',
     '__stdin__',
     '__stdout__',
     '_clear_type_cache',
     '_current_frames',
     '_debugmallocstats',
     '_enablelegacywindowsfsencoding',
     '_getframe',
     '_git',
     '_home',
     '_xoptions',
     'api_version',
     'argv',
     'base_exec_prefix',
     'base_prefix',
     'builtin_module_names',
     'byteorder',
     'call_tracing',
     'callstats',
     'copyright',
     'displayhook',
     'dllhandle',
     'dont_write_bytecode',
     'exc_info',
     'excepthook',
     'exec_prefix',
     'executable',
     'exit',
     'flags',
     'float_info',
     'float_repr_style',
     'get_asyncgen_hooks',
     'get_coroutine_wrapper',
     'getallocatedblocks',
     'getcheckinterval',
     'getdefaultencoding',
     'getfilesystemencodeerrors',
     'getfilesystemencoding',
     'getprofile',
     'getrecursionlimit',
     'getrefcount',
     'getsizeof',
     'getswitchinterval',
     'gettrace',
     'getwindowsversion',
     'hash_info',
     'hexversion',
     'implementation',
     'int_info',
     'intern',
     'is_finalizing',
     'maxsize',
     'maxunicode',
     'meta_path',
     'modules',
     'path',
     'path_hooks',
     'path_importer_cache',
     'platform',
     'prefix',
     'ps1',
     'ps2',
     'ps3',
     'set_asyncgen_hooks',
     'set_coroutine_wrapper',
     'setcheckinterval',
     'setprofile',
     'setrecursionlimit',
     'setswitchinterval',
     'settrace',
     'stderr',
     'stdin',
     'stdout',
     'thread_info',
     'version',
     'version_info',
     'warnoptions',
     'winver']



# 包
* 包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。
* 在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。
* 目录只有包含一个叫做 \__init\__.py 的文件才会被认作是一个包。
