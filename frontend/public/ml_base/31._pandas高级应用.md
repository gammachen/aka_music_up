# 分类数据
pandas的分类类型能够提高性能和内存的使用率。
# 问题
表中的一列通常会有重复的包含不同值的小集合的情况。我们已经学过了unique和value_counts，它们可以从数组提取出不同的值，并分别计算频率：


```python
import pandas as pd
import tushare as ts
```


```python
df=ts.get_stock_basics()
df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>industry</th>
      <th>area</th>
      <th>pe</th>
      <th>outstanding</th>
      <th>totals</th>
      <th>totalAssets</th>
      <th>liquidAssets</th>
      <th>fixedAssets</th>
      <th>reserved</th>
      <th>...</th>
      <th>bvps</th>
      <th>pb</th>
      <th>timeToMarket</th>
      <th>undp</th>
      <th>perundp</th>
      <th>rev</th>
      <th>profit</th>
      <th>gpr</th>
      <th>npr</th>
      <th>holders</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>N鹏鼎</td>
      <td>元器件</td>
      <td>深圳</td>
      <td>62.15</td>
      <td>2.31</td>
      <td>23.11</td>
      <td>2032557.75</td>
      <td>1040264.13</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>...</td>
      <td>5.69</td>
      <td>4.07</td>
      <td>20180918</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>4.54</td>
      <td>408095.0</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>升达林业</td>
      <td>供气供热</td>
      <td>四川</td>
      <td>0.00</td>
      <td>7.24</td>
      <td>7.52</td>
      <td>284906.13</td>
      <td>171517.98</td>
      <td>79040.80</td>
      <td>71885.80</td>
      <td>...</td>
      <td>2.18</td>
      <td>1.90</td>
      <td>20080716</td>
      <td>13266.97</td>
      <td>0.18</td>
      <td>-14.18</td>
      <td>-466.68</td>
      <td>12.10</td>
      <td>-6.56</td>
      <td>37927.0</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>恒康医疗</td>
      <td>中成药</td>
      <td>甘肃</td>
      <td>46.30</td>
      <td>18.65</td>
      <td>18.65</td>
      <td>1004764.88</td>
      <td>319343.19</td>
      <td>203795.13</td>
      <td>108219.77</td>
      <td>...</td>
      <td>2.28</td>
      <td>1.57</td>
      <td>20080306</td>
      <td>118436.72</td>
      <td>0.63</td>
      <td>67.86</td>
      <td>-56.30</td>
      <td>31.11</td>
      <td>3.88</td>
      <td>24831.0</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>红宇新材</td>
      <td>钢加工</td>
      <td>湖南</td>
      <td>0.00</td>
      <td>3.27</td>
      <td>4.41</td>
      <td>94718.11</td>
      <td>45858.59</td>
      <td>20612.00</td>
      <td>24669.55</td>
      <td>...</td>
      <td>1.64</td>
      <td>2.92</td>
      <td>20120801</td>
      <td>1418.97</td>
      <td>0.03</td>
      <td>-39.70</td>
      <td>-95.66</td>
      <td>25.88</td>
      <td>-4.96</td>
      <td>54901.0</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>迪威迅</td>
      <td>通信设备</td>
      <td>深圳</td>
      <td>0.00</td>
      <td>3.00</td>
      <td>3.00</td>
      <td>118868.60</td>
      <td>65652.96</td>
      <td>6827.10</td>
      <td>31287.58</td>
      <td>...</td>
      <td>2.32</td>
      <td>2.31</td>
      <td>20110125</td>
      <td>6951.87</td>
      <td>0.23</td>
      <td>-34.11</td>
      <td>-1324.05</td>
      <td>21.03</td>
      <td>-9.96</td>
      <td>20000.0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 22 columns</p>
</div>




```python
stock=df.loc[:,['industry','area']]
stock.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>industry</th>
      <th>area</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>元器件</td>
      <td>深圳</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>供气供热</td>
      <td>四川</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>中成药</td>
      <td>甘肃</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>钢加工</td>
      <td>湖南</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>通信设备</td>
      <td>深圳</td>
    </tr>
  </tbody>
</table>
</div>




```python
stock.area.unique()
```




    array(['深圳', '四川', '甘肃', '湖南', '安徽', '浙江', '上海', '广西', '重庆', '江苏', '宁夏',
           '山东', '陕西', '湖北', '广东', '福建', '青海', '北京', '西藏', '贵州', '新疆', '河南',
           '山西', '江西', '辽宁', '云南', '黑龙江', '吉林', '海南', '河北', '天津', '内蒙'],
          dtype=object)




```python
stock.area.value_counts()
```




    浙江     429
    江苏     398
    北京     314
    广东     304
    上海     284
    深圳     282
    山东     194
    福建     131
    四川     120
    安徽     104
    湖南     103
    湖北     100
    河南      79
    辽宁      72
    河北      56
    新疆      53
    天津      50
    重庆      48
    陕西      47
    江西      41
    吉林      41
    山西      38
    广西      37
    黑龙江     37
    甘肃      33
    云南      33
    海南      31
    贵州      29
    内蒙      25
    西藏      17
    宁夏      13
    青海      12
    Name: area, dtype: int64



许多数据系统（数据仓库、统计计算或其它应用）都发展出了特定的表征重复值的方法，以进行高效的存储和计算。在数据仓库中，最好的方法是使用所谓的包含不同值得维表(Dimension Table)，将主要的参数存储为引用维表整数键：


```python
v=pd.Series([0,1,0,0]*2)
d=pd.Series(['horse','sheep'])
v,d
```




    (0    0
     1    1
     2    0
     3    0
     4    0
     5    1
     6    0
     7    0
     dtype: int64, 0    horse
     1    sheep
     dtype: object)




```python
d.take(v)
```




    0    horse
    1    sheep
    0    horse
    0    horse
    0    horse
    1    sheep
    0    horse
    0    horse
    dtype: object



这种用整数表示的方法称为分类或字典编码表示法。不同值得数组称为分类、字典或数据级。表示分类的整数值称为分类编码或简单地称为编码。
分类表示可以在进行分析时大大的提高性能。你也可以在保持编码不变的情况下，对分类进行转换。一些相对简单的转变例子包括：
* 重命名分类。
* 加入一个新的分类，不改变已经存在的分类的顺序或位置。


# pandas的分类类型
pandas有一个特殊的分类类型，用于保存使用整数分类表示法的数据。


```python
area=df.area.astype('category')
area.head()
```




    code
    002938    深圳
    002259    四川
    002219    甘肃
    300345    湖南
    300167    深圳
    Name: area, dtype: category
    Categories (32, object): [上海, 云南, 内蒙, 北京, ..., 重庆, 陕西, 青海, 黑龙江]




```python
type(area.values)
```




    pandas.core.arrays.categorical.Categorical




```python
c=area.values
```


```python
c.categories,c.codes
```




    (Index(['上海', '云南', '内蒙', '北京', '吉林', '四川', '天津', '宁夏', '安徽', '山东', '山西', '广东',
            '广西', '新疆', '江苏', '江西', '河北', '河南', '浙江', '海南', '深圳', '湖北', '湖南', '甘肃',
            '福建', '西藏', '贵州', '辽宁', '重庆', '陕西', '青海', '黑龙江'],
           dtype='object'), array([20,  5, 23, ..., 18, 17, 24], dtype=int8))



将DF的列转化为分类类型


```python
cat=stock.assign(area=stock.area.astype('category'))
cat.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>industry</th>
      <th>area</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>元器件</td>
      <td>深圳</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>供气供热</td>
      <td>四川</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>中成药</td>
      <td>甘肃</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>钢加工</td>
      <td>湖南</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>通信设备</td>
      <td>深圳</td>
    </tr>
  </tbody>
</table>
</div>




```python
cat.area.head()
```




    code
    002938    深圳
    002259    四川
    002219    甘肃
    300345    湖南
    300167    深圳
    Name: area, dtype: category
    Categories (32, object): [上海, 云南, 内蒙, 北京, ..., 重庆, 陕西, 青海, 黑龙江]



# 用分类进行计算
使用pandas.qcut面元函数。它会返回category对象


```python
bins=pd.qcut(df.pe,6)
```


```python
bins.head()
```




    code
    002938    (37.607, 67.027]
    002259      (-0.001, 9.73]
    002219    (37.607, 67.027]
    300345      (-0.001, 9.73]
    300167      (-0.001, 9.73]
    Name: pe, dtype: category
    Categories (6, interval[float64]): [(-0.001, 9.73] < (9.73, 17.787] < (17.787, 25.77] < (25.77, 37.607] < (37.607, 67.027] < (67.027, 8203.07]]




```python
bins=pd.qcut(df.pe,6,labels=list('abcdef'))
bins.head()
```




    code
    002938    e
    002259    a
    002219    e
    300345    a
    300167    a
    Name: pe, dtype: category
    Categories (6, object): [a < b < c < d < e < f]




```python
bins.values.categories,bins.values.codes
```




    (Index(['a', 'b', 'c', 'd', 'e', 'f'], dtype='object'),
     array([4, 0, 4, ..., 0, 0, 0], dtype=int8))



加上标签的面元分类不包含数据面元边界的信息，因此可以使用groupby提取一些汇总信息：


```python
df.pe.groupby(bins).agg(['count','mean'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>count</th>
      <th>mean</th>
    </tr>
    <tr>
      <th>pe</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>593</td>
      <td>2.664250</td>
    </tr>
    <tr>
      <th>b</th>
      <td>592</td>
      <td>14.162584</td>
    </tr>
    <tr>
      <th>c</th>
      <td>593</td>
      <td>21.694401</td>
    </tr>
    <tr>
      <th>d</th>
      <td>592</td>
      <td>31.164122</td>
    </tr>
    <tr>
      <th>e</th>
      <td>592</td>
      <td>49.758514</td>
    </tr>
    <tr>
      <th>f</th>
      <td>593</td>
      <td>259.201282</td>
    </tr>
  </tbody>
</table>
</div>



# 用分类提高性能
如果你是在一个特定数据集上做大量分析，将其转换为分类可以极大地提高效率。DataFrame列的分类使用的内存通常少的多。


```python
cat=df.area.astype("category")
```


```python
cat.memory_usage(),df.area.memory_usage()
```




    (197371, 220720)



# 为建模创建虚拟变量
当你使用统计或机器学习工具时，通常会将分类数据转换为虚拟变量，也称为one-hot编码。这包括创建一个不同类别的列的DataFrame；这些列包含给定分类的1，其它为0


```python
pd.get_dummies(df.area.astype('category')).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>上海</th>
      <th>云南</th>
      <th>内蒙</th>
      <th>北京</th>
      <th>吉林</th>
      <th>四川</th>
      <th>天津</th>
      <th>宁夏</th>
      <th>安徽</th>
      <th>山东</th>
      <th>...</th>
      <th>湖南</th>
      <th>甘肃</th>
      <th>福建</th>
      <th>西藏</th>
      <th>贵州</th>
      <th>辽宁</th>
      <th>重庆</th>
      <th>陕西</th>
      <th>青海</th>
      <th>黑龙江</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 32 columns</p>
</div>



# GroupBy高级应用,分组转换和“解封”GroupBy
我们在分组操作中学习了apply方法，进行转换。还有另一个transform方法，它与apply很像，但是对使用的函数有一定限制：

* 它可以产生向分组形状广播标量值
* 它可以产生一个和输入组形状相同的对象
* 它不能修改输入



```python
g=df.loc[:,['area','pe']].groupby('area')
g.mean().head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>pe</th>
    </tr>
    <tr>
      <th>area</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>上海</th>
      <td>47.486514</td>
    </tr>
    <tr>
      <th>云南</th>
      <td>121.247576</td>
    </tr>
    <tr>
      <th>内蒙</th>
      <td>21.831200</td>
    </tr>
    <tr>
      <th>北京</th>
      <td>72.518662</td>
    </tr>
    <tr>
      <th>吉林</th>
      <td>53.978049</td>
    </tr>
  </tbody>
</table>
</div>



假设我们想产生一个和df.loc[:,['area','pe']]形状相同的Series，但值替换为按键分组的平均值。我们可以传递函数lambda x: x.mean()进行转换：


```python
g.transform(lambda x:x.mean()).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>pe</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>82.186418</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>51.206917</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>27.800303</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>77.246408</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>82.186418</td>
    </tr>
  </tbody>
</table>
</div>




```python
g.transform('count').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>pe</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>282</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>120</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>33</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>103</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>282</td>
    </tr>
  </tbody>
</table>
</div>



我们可以计算每个分组的降序排名


```python
g.transform(lambda x:x.rank(ascending=False)).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>pe</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>61.0</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>114.0</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>8.0</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>94.5</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>271.0</td>
    </tr>
  </tbody>
</table>
</div>



看一个由简单聚合构造的分组转化函数


```python
g.transform(lambda x:(x-x.mean())/x.std()).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>pe</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>-0.084609</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>-0.717331</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>0.564356</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>-0.242314</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>-0.347052</td>
    </tr>
  </tbody>
</table>
</div>



我们可以用tansform或者apply可以获得等价结果


```python
g.apply(lambda x:(x-x.mean())/x.std()).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>pe</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>-0.084609</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>-0.717331</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>0.564356</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>-0.242314</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>-0.347052</td>
    </tr>
  </tbody>
</table>
</div>



内置的聚合函数，比如mean或sum，通常比apply函数快，也比transform快。这允许我们进行一个所谓的解封（unwrapped）分组操作：


```python
((df.loc[:,['pe']]-g.transform('mean'))/g.transform('std')).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>pe</th>
    </tr>
    <tr>
      <th>code</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>002938</th>
      <td>-0.084609</td>
    </tr>
    <tr>
      <th>002259</th>
      <td>-0.717331</td>
    </tr>
    <tr>
      <th>002219</th>
      <td>0.564356</td>
    </tr>
    <tr>
      <th>300345</th>
      <td>-0.242314</td>
    </tr>
    <tr>
      <th>300167</th>
      <td>-0.347052</td>
    </tr>
  </tbody>
</table>
</div>



# 股票行业地域热力图


```python
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
sns.set_style('whitegrid',{'font.sans-serif':['simhei','Arial']})
a=df.loc[:,['industry','area','pe']]
b=a.groupby(['industry','area']).count()
b.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>pe</th>
    </tr>
    <tr>
      <th>industry</th>
      <th>area</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">专用机械</th>
      <th>上海</th>
      <td>10</td>
    </tr>
    <tr>
      <th>北京</th>
      <td>7</td>
    </tr>
    <tr>
      <th>四川</th>
      <td>6</td>
    </tr>
    <tr>
      <th>天津</th>
      <td>1</td>
    </tr>
    <tr>
      <th>安徽</th>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>




```python
c=b.reset_index()
c.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>industry</th>
      <th>area</th>
      <th>pe</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>专用机械</td>
      <td>上海</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1</th>
      <td>专用机械</td>
      <td>北京</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>专用机械</td>
      <td>四川</td>
      <td>6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>专用机械</td>
      <td>天津</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>专用机械</td>
      <td>安徽</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>




```python
d=c.pivot('industry','area','pe')
d.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>area</th>
      <th>上海</th>
      <th>云南</th>
      <th>内蒙</th>
      <th>北京</th>
      <th>吉林</th>
      <th>四川</th>
      <th>天津</th>
      <th>宁夏</th>
      <th>安徽</th>
      <th>山东</th>
      <th>...</th>
      <th>湖南</th>
      <th>甘肃</th>
      <th>福建</th>
      <th>西藏</th>
      <th>贵州</th>
      <th>辽宁</th>
      <th>重庆</th>
      <th>陕西</th>
      <th>青海</th>
      <th>黑龙江</th>
    </tr>
    <tr>
      <th>industry</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>专用机械</th>
      <td>10.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>7.0</td>
      <td>NaN</td>
      <td>6.0</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>8.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>中成药</th>
      <td>3.0</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>5.0</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>...</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>乳制品</th>
      <td>2.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>互联网</th>
      <td>5.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>11.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>3.0</td>
      <td>...</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>5.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>仓储物流</th>
      <td>6.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 32 columns</p>
</div>




```python
e=d.sort_values(by=df.area.unique().tolist())
e.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>area</th>
      <th>上海</th>
      <th>云南</th>
      <th>内蒙</th>
      <th>北京</th>
      <th>吉林</th>
      <th>四川</th>
      <th>天津</th>
      <th>宁夏</th>
      <th>安徽</th>
      <th>山东</th>
      <th>...</th>
      <th>湖南</th>
      <th>甘肃</th>
      <th>福建</th>
      <th>西藏</th>
      <th>贵州</th>
      <th>辽宁</th>
      <th>重庆</th>
      <th>陕西</th>
      <th>青海</th>
      <th>黑龙江</th>
    </tr>
    <tr>
      <th>industry</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>百货</th>
      <td>6.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>5.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>...</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>4.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>造纸</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>5.0</td>
      <td>...</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>旅游景点</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>...</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>超市连锁</th>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>...</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>铅锌</th>
      <td>NaN</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 32 columns</p>
</div>




```python
plt.figure(figsize=(15,15))
sns.heatmap(e)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1f086051198>




    
![png](31._pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8_files/31._pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8_47_1.png)
    


# 管道方法


```python
plt.figure(figsize=(15,15))
df \
.pipe(lambda x:x.loc[:,['industry','area','pe']]) \
.pipe(lambda x:x.groupby(['industry','area']).count()) \
.pipe(lambda x:x.reset_index().pivot('industry','area','pe').sort_values(by=df.loc[:,'area'].unique().tolist())) \
.pipe(lambda x:sns.heatmap(x))
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1f08ae28b70>




    
![png](31._pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8_files/31._pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8_49_1.png)
    

