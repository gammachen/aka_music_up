# 将列表当做堆栈使用
列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。


```python
ls=[1,2]
ls.append(3)
```


```python
print(ls)
```

    [1, 2, 3]



```python
print(ls.pop())
```

    2



```python
print(ls)
```

    [1]


# 队列
* 先进先出


```python
from collections import deque
```


```python
queue=deque(range(10))
print(queue)
```

    deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



```python
queue.append(11)
print(queue)
```

    deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 11])



```python
print(queue.popleft())
```

    0



```python
print(queue)
```

    deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 11])


# 列表推导式
* 列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。
* 每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。


```python
ls=[1,2,3,4]
print([i*2 for i in ls])
```

    [2, 4, 6, 8]



```python
ls=[1,2,3,4]
xa=[[i,i*2] for i in ls]
print(xa)
```

    [[1, 2], [2, 4], [3, 6], [4, 8]]



```python
ls=range(20)
xa=[i for i in ls if i % 3==0]
print(xa)
```

    [0, 3, 6, 9, 12, 15, 18]



```python
ls1=range(3)
ls2=range(3,6,1)
xa=[i*j for i in ls1 for j in ls2]
print(xa)
```

    [0, 0, 0, 3, 4, 5, 6, 8, 10]



```python
print([i for i in range(3,6,1)])
```

    [3, 4, 5]

