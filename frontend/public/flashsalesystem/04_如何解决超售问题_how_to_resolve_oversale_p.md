---

### **超卖问题解决方案设计文档**

---

#### **一、核心解决思路**  
通过 **数据库事务保障强一致性** + **Redis预扣库存实现高性能** + **异步持久化与补偿机制** 三重设计，实现高并发场景下库存扣减的 **零超卖** 与 **高可用**。架构核心分层如下：  
1. **防重校验层**：Redis Lua脚本防并发重复请求。  
2. **预扣库存层**：Redis单线程原子操作保证强一致性。  
3. **数据持久层**：MySQL乐观锁兜底，异步任务校准数据。  
4. **异常补偿层**：任务表记录操作流水，异常时回滚。  

---

### **二、核心方案详述**  

#### **1. 数据库层：乐观锁 + 事务批量回滚**  
- **实现逻辑**：  
  ```sql
  -- 乐观锁示例（版本号机制）
  UPDATE sku_stock 
  SET stock = stock - #{num}, version = version + 1 
  WHERE sku_id = #{skuId} AND version = #{currentVersion} 
    AND stock >= #{num};
  ```
- **优势**：  
  - 强一致性保障：通过数据库事务确保扣减原子性。  
  - 批量回滚能力：部分失败时事务自动回滚（如批量扣减10件，仅5件成功）。  
- **劣势**：  
  - 性能瓶颈：依赖数据库行锁，高并发下TPS受限（需SSD+高端硬件补足，如Oracle+刀锋服务器可达单机万级TPS）。  

---

#### **2. Redis层：Lua脚本单线程扣减**  
- **实现逻辑**：  
  ```lua
  -- Redis Lua脚本（原子扣减+防重）
  local key = KEYS[1]        -- 库存Key（如:sku_stock:1001）
  local uuid = ARGV[1]       -- 请求唯一标识
  local deduct_num = tonumber(ARGV[2])  -- 扣减数量
  
  -- 防重校验
  if redis.call("EXISTS", "dedup:"..uuid) == 1 then
    return 0  -- 重复请求
  end
  
  -- 库存预扣
  local stock = tonumber(redis.call("GET", key))
  if stock < deduct_num then
    return -1  -- 库存不足
  end
  
  -- 扣减库存并标记防重
  redis.call("DECRBY", key, deduct_num)
  redis.call("SET", "dedup:"..uuid, 1, "EX", 60)  -- 防重标记60秒过期
  return 1  -- 扣减成功
  ```
- **优势**：  
  - **零超卖**：单线程模型天然避免并发冲突。  
  - **高性能**：内存操作，单节点可达10万+ TPS。  
  - **防重设计**：UUID唯一标识拦截重复请求。  
- **劣势**：  
  - **少卖风险**：Redis宕机时未持久化数据可能丢失（需异步校准）。  

---

#### **3. 异步持久化与补偿**  
- **流程设计**：  
  1. **任务表写入**：  
     - Redis扣减成功后，同步插入任务表（记录SKU、数量、状态），作为事务日志（Undo Log）。  
     ```sql
     INSERT INTO stock_deduct_task (task_id, sku_id, num, status) 
     VALUES (#{taskId}, #{skuId}, #{num}, 'PRE_DEDUCT');
     ```
  2. **异步持久化**：  
     - 后台Worker消费任务表，将Redis扣减结果同步至数据库。  
     ```sql
     UPDATE sku_stock SET stock = stock - #{num} WHERE sku_id = #{skuId};
     UPDATE stock_deduct_task SET status = 'SYNCED' WHERE task_id = #{taskId};
     ```
  3. **异常补偿**：  
     - 若Redis扣减后异步同步失败（如网络超时、宕机），通过任务表扫描未完成记录，触发重试或回滚。  

---

### **三、辅助方案增强设计**  

#### **1. 前置校验优化**  
- **读写分离**：  
  - 前置校验（库存是否充足）走缓存读（Redis），避免穿透数据库。  
  - 缓存预热：活动开始前加载库存至Redis。  
- **卖完标记**：  
  - 库存归零时，Redis设置标记（如`sold_out:sku_id=1`），后续请求直接拦截，减少无意义查询。  

#### **2. 极端场景容灾**  
- **Redis宕机恢复**：  
  - 通过任务表数据重新校准Redis库存（`校准值 = 数据库库存 - 未同步任务数`）。  
- **数据库与Redis不一致**：  
  - 定时对账任务：扫描数据库与Redis差异，触发告警并自动修复。  

#### **3. 水平扩展能力**  
- **任务表分库分表**：  
  - 按SKU ID哈希分片，支撑海量扣减任务。  
- **Redis集群化**：  
  - 分片集群（如Redis Cluster）提升容量与吞吐量。  

---

### **四、整体流程示意图**  
```plaintext
1. 用户请求 → 2. 防重校验（Redis查重）  
               ↓  
3. Redis预扣库存（Lua脚本） → 失败 → 返回“库存不足”  
               ↓ 成功  
4. 写入任务表（状态=PRE_DEDUCT）  
               ↓  
5. 异步同步数据库（Worker消费任务表）  
               ↓ 成功/失败  
6. 更新任务状态（SYNCED/FAILED）  
               ↓ 失败  
7. 补偿任务重试或回滚（Undo Log）  
```

---

### **五、方案对比与选型建议**  

| **方案**                | **超卖风险** | **性能**   | **复杂度** | **适用场景**               |  
|-------------------------|--------------|------------|------------|----------------------------|  
| 纯数据库乐观锁          | 无           | 低（1k~1w TPS） | 低         | 低并发、强一致性要求       |  
| Redis Lua预扣 + 异步同步 | 无           | 高（10w+ TPS）  | 中         | 高并发、容忍短暂不一致     |  
| 纯Redis缓存方案         | 可能少卖     | 极高（50w+ TPS） | 高         | 秒杀峰值、允许手动对账修复 |  

---

### **六、总结**  
1. **零超卖保障**：  
   - Redis单线程扣减 + 数据库乐观锁双重防线。  
2. **高性能核心**：  
   - 所有扣减逻辑在Redis内存完成，数据库仅异步持久化。  
3. **故障自愈能力**：  
   - 任务表Undo Log实现数据最终一致，补偿机制覆盖网络超时、宕机等异常。  
4. **扩展性设计**：  
   - 任务表水平分库、Redis集群化支撑亿级流量。  

--- 

**附：部署建议**  
- **Redis**：至少主从集群 + 持久化（AOF每秒刷盘）。  
- **数据库**：Oracle/MySQL + SSD，主从读写分离。  
- **监控**：Redis内存/命中率、任务表堆积量、数据库同步延迟。

