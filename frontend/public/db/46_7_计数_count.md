在 MySQL 中，`COUNT(*)` 和 `COUNT(col)` 的行为和性能存在显著差异，具体取决于以下因素：

---

### **1. 语义差异**
| 表达式               | 行为                                                                 |
|----------------------|----------------------------------------------------------------------|
| **`COUNT(*)`**       | 统计所有行的数量，**无论列值是否为 `NULL`**。                          |
| **`COUNT(col)`**     | 统计指定列 `col` 中 **非 `NULL` 值的数量**（会跳过 `NULL` 值）。         |

**示例**：  
假设表 `users` 有 5 行数据，其中 `age` 列有 3 行非 `NULL` 值：
```sql
SELECT COUNT(*) FROM users;    -- 结果：5（统计所有行）
SELECT COUNT(age) FROM users;  -- 结果：3（跳过 `NULL` 值）
```

---

### **2. 性能差异**
#### **场景 1：`COUNT(*)` 的性能**
- **InnoDB 引擎**：  
  `COUNT(*)` 需要扫描表（或选择最小的二级索引）统计行数，**不会跳过 `NULL` 值**。  
  - 如果表有二级索引，优化器会优先选择更小的二级索引来加速统计。  
  - 若需要精确值，`COUNT(*)` 的性能通常与表大小正相关。  

- **MyISAM 引擎**：  
  `COUNT(*)` 直接返回存储的元数据行数（无 `WHERE` 条件时 **瞬时完成**）。

**示例**：  
```sql
-- InnoDB 表：使用二级索引统计行数
EXPLAIN SELECT COUNT(*) FROM users; 
-- 可能选择 `idx_email`（更小的索引）
```

#### **场景 2：`COUNT(col)` 的性能**
- **如果 `col` 有索引**：  
  `COUNT(col)` 会使用索引统计非 `NULL` 值的数量（索引大小影响性能）。  
- **如果 `col` 无索引**：  
  需要全表扫描，检查每一行的 `col` 是否为 `NULL`，性能较差。

**示例**：  
```sql
-- 假设 `age` 列有索引
EXPLAIN SELECT COUNT(age) FROM users;
-- 使用 `idx_age` 索引，快速统计非 `NULL` 值数量
```

---

### **3. 索引的影响**
| 场景                     | `COUNT(*)`                           | `COUNT(col)`                       |
|--------------------------|--------------------------------------|-------------------------------------|
| **主键索引**             | 可能扫描主键索引（较大）              | 若 `col` 是主键，等效于 `COUNT(*)`   |
| **二级索引**             | 选择最小的二级索引（更高效）          | 若 `col` 有二级索引，直接使用该索引  |
| **无索引**               | 全表扫描                             | 全表扫描并检查 `NULL`               |

**示例**：  
```sql
-- 表结构：id (主键), name (无索引), age (有索引)
SELECT COUNT(*) FROM users;     -- 可能选择 `age` 的二级索引
SELECT COUNT(name) FROM users;  -- 全表扫描，检查 `name` 是否为 NULL
```

---

### **4. 存储引擎差异**
| 存储引擎   | `COUNT(*)` 行为                                | `COUNT(col)` 行为                              |
|------------|-----------------------------------------------|------------------------------------------------|
| **InnoDB** | 需扫描表或二级索引（无缓存行数）               | 依赖 `col` 的索引或全表扫描                      |
| **MyISAM** | 直接返回元数据行数（无 `WHERE` 时瞬时完成）     | 需扫描表或索引（性能与 `col` 的索引相关）         |

**示例**：  
```sql
-- MyISAM 表（无 WHERE 条件）
SELECT COUNT(*) FROM users;    -- 瞬时返回（元数据）
SELECT COUNT(age) FROM users;  -- 需扫描 `age` 索引
```

---

### **5. 优化建议**
1. **统计所有行数时，优先使用 `COUNT(*)`**：  
   - 语义明确，性能在多数场景下优于 `COUNT(col)`。  
   - 在 InnoDB 中，若需要频繁统计大表行数，可维护冗余计数表。  

2. **统计非 `NULL` 值时使用 `COUNT(col)`**：  
   - 确保 `col` 有索引以加速查询。  

3. **避免 `COUNT(1)` 或 `COUNT(主键)`**：  
   - 在 MySQL 中，`COUNT(*)` 已优化为最佳实践，无需改写为其他形式。

---

### **总结**
| 对比项         | `COUNT(*)`                                  | `COUNT(col)`                                  |
|----------------|---------------------------------------------|-----------------------------------------------|
| **语义**       | 统计所有行（包括 `NULL`）                   | 统计 `col` 的非 `NULL` 值                     |
| **性能**       | 通常更优（优先选择最小二级索引）            | 依赖 `col` 的索引质量                         |
| **索引利用**   | 可能使用二级索引                            | 必须依赖 `col` 的索引（否则全表扫描）          |
| **适用场景**   | 需要精确行数时                              | 需排除 `NULL` 值的统计场景                    |

合理选择 `COUNT(*)` 或 `COUNT(col)`，结合索引设计和业务需求，可以显著优化查询性能。