---

### **问题分析与解决方案**

---

#### **一、问题根源分析**

1. **单列索引 vs 复合索引的性能差异**  
   - **单列索引 (a1)**：  
     - **结构**：仅包含 `a1` 和主键，索引条目小，B+树层级低。  
     - **查询 `SELECT COUNT(*) WHERE a1='1'`**：  
       - 直接通过索引统计匹配行数，无需回表。  
       - 每个索引页可存储更多条目，减少 I/O 次数。  
   - **复合索引 (a1, a2, a3)**：  
     - **结构**：包含 `a1`、`a2`、`a3` 和主键，索引条目大，B+树层级可能更高。  
     - **查询 `SELECT COUNT(*) WHERE a1='1'`**：  
       - 虽然覆盖 `a1` 条件，但因索引条目大，每个页存储的条目数减少，需更多 I/O 操作。  

2. **性能下降的直接原因**  
   - 删除单列索引后，优化器被迫使用复合索引。  
   - 复合索引的 **索引页密度更低**，导致扫描相同数据量需要更多磁盘 I/O，性能下降。

---

#### **二、核心矛盾与权衡**

| 索引类型       | 适用场景                                   | 优势                        | 劣势                          |
|----------------|-------------------------------------------|-----------------------------|-------------------------------|
| **单列索引**   | 仅需 `a1` 条件的查询（如 `COUNT(*)`）       | 索引条目小，I/O 效率高       | 无法覆盖 `a2`、`a3` 字段        |
| **复合索引**   | 需要 `a1` 且返回 `a1,a2,a3` 的查询         | 覆盖查询，避免回表            | 索引条目大，统计类查询效率低    |

---

#### **三、解决方案**

##### **1. 最佳实践：保留单列索引并新增复合索引**
- **操作步骤**：  
  ```sql
  -- 恢复单列索引
  ALTER TABLE tb ADD INDEX idx_a1 (a1);
  
  -- 新增复合索引
  ALTER TABLE tb ADD INDEX idx_a1_a2_a3 (a1, a2, a3);
  ```
- **优势**：  
  - `SELECT COUNT(*) WHERE a1='1'` 使用单列索引，保持高性能。  
  - `SELECT a1,a2,a3 WHERE a1='1'` 使用复合索引，避免回表。  

##### **2. 优化器如何选择索引？**
- **索引选择规则**：  
  - 优化器优先选择 **覆盖索引**（避免回表）。  
  - 若存在多个可用索引，选择 **基数更低（选择性更高）** 的索引。  
- **示例执行计划**：  
  ```sql
  -- 查询 1: COUNT(*) 使用单列索引
  EXPLAIN SELECT COUNT(*) FROM tb WHERE a1 = '1';
  +----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------------+
  | id | select_type | table | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra       |
  +----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------------+
  | 1  | SIMPLE      | tb    | NULL       | ref  | idx_a1        | idx_a1 | 4       | const | 100  | 100.00   | Using index |
  +----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------------+
  
  -- 查询 2: SELECT a1,a2,a3 使用复合索引
  EXPLAIN SELECT a1,a2,a3 FROM tb WHERE a1 = '1';
  +----+-------------+-------+------------+------+---------------+----------------+---------+-------+------+----------+-------------+
  | id | select_type | table | partitions | type | possible_keys | key            | key_len | ref   | rows | filtered | Extra       |
  +----+-------------+-------+------------+------+---------------+----------------+---------+-------+------+----------+-------------+
  | 1  | SIMPLE      | tb    | NULL       | ref  | idx_a1,idx_a1_a2_a3 | idx_a1_a2_a3 | 4       | const | 100  | 100.00   | Using index |
  +----+-------------+-------+------------+------+---------------+----------------+---------+-------+------+----------+-------------+
  ```

##### **3. 为何不能仅保留复合索引？**
- **索引条目大小对比**（假设 `a1` 为 INT，`a2`、`a3` 为 VARCHAR(255)）：  
  - 单列索引：`4 字节（a1） + 4 字节（主键） = 8 字节`  
  - 复合索引：`4 字节（a1） + 255 字节（a2） + 255 字节（a3） + 4 字节（主键） = 518 字节`  
- **索引页存储条目数**（假设页大小为 16KB）：  
  - 单列索引：`16KB / 8 字节 ≈ 2000 条/页`  
  - 复合索引：`16KB / 518 字节 ≈ 31 条/页`  
- **性能影响**：  
  - 复合索引扫描相同行数需要 **64 倍** 的 I/O 操作（2000 vs 31 条/页），导致 `COUNT(*)` 性能显著下降。

---

#### **四、索引维护成本权衡**

| 操作            | 单列索引维护成本 | 复合索引维护成本 | 总成本          |
|-----------------|------------------|------------------|-----------------|
| INSERT/UPDATE   | 低               | 高               | 中              |
| 存储空间        | 低               | 高               | 中              |
| 查询性能优化    | 高（针对 COUNT） | 高（针对 SELECT）| 高              |

**结论**：  
在 **读多写少** 的场景中，保留两个索引的综合收益更高；在 **写多读少** 的场景中，需评估是否值得牺牲写入性能换取查询优化。

---

#### **五、高级优化方案**

##### **1. 使用覆盖索引 + 延迟关联（适用于分页查询）**
```sql
-- 原查询（回表开销大）
SELECT a1,a2,a3 FROM tb WHERE a1 = '1' LIMIT 1000;

-- 优化后（利用复合索引直接返回数据）
-- 无需优化，复合索引已覆盖所有字段。
```

##### **2. 监控索引使用率**
```sql
-- 检查未使用的索引
SELECT * FROM sys.schema_unused_indexes WHERE table_name = 'tb';

-- 检查索引扫描效率
SELECT 
  index_name,
  rows_read,
  rows_avg_fetch_time 
FROM sys.schema_index_statistics 
WHERE table_name = 'tb';
```

##### **3. 分区表优化（超大数据量场景）**
```sql
-- 按 a1 范围分区
CREATE TABLE tb (
  a1 INT,
  a2 VARCHAR(255),
  a3 VARCHAR(255),
  PRIMARY KEY (a1),
  INDEX idx_a1_a2_a3 (a1, a2, a3)
) PARTITION BY RANGE (a1) (
  PARTITION p0 VALUES LESS THAN (1000),
  PARTITION p1 VALUES LESS THAN (2000)
);
```

---

### **总结**
- **根本原因**：复合索引的条目大小导致 I/O 效率下降，影响 `COUNT(*)` 性能。  
- **解决方案**：同时保留单列索引和复合索引，让优化器根据查询类型选择最优索引。  
- **设计原则**：  
  - **高频查询专用索引**：为 `COUNT(*)` 等简单查询保留轻量级索引。  
  - **覆盖索引优先**：为需要返回多字段的查询设计复合索引。  
  - **监控与调优**：定期清理冗余索引，平衡读写性能。

