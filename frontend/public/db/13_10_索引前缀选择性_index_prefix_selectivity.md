### **前缀索引长度确定方法与实施步骤**

---

#### **一、核心原理**
前缀索引需要在 **存储效率** 和 **查询性能** 之间取得平衡：  
- **前缀过短**：选择性低，导致大量重复值，查询效率下降。  
- **前缀过长**：索引体积增大，内存利用率降低。  

**核心目标**：找到最小的前缀长度，使得其选择性接近完整列的选择性。

---

#### **二、实施步骤与示例**

##### **1. 计算完整列的选择性**
**步骤**：  
- 统计完整列的唯一值比例，作为基准选择性。  

**示例**（表 `users`，列 `email`）：  
```sql
SELECT 
  COUNT(DISTINCT email) / COUNT(*) AS full_selectivity
FROM users;
```
**输出**：  
```
+------------------+
| full_selectivity |
+------------------+
| 0.9923           |
+------------------+
```
**结论**：完整列选择性为 **99.23%**，前缀索引的选择性应尽量接近该值。

---

##### **2. 测试不同前缀长度的选择性**
**步骤**：  
- 逐步增加前缀长度（如 5, 10, 15, 20），计算每个长度的选择性。  
- 找到选择性增长趋缓的拐点。  

**示例**：  
```sql
SELECT 
  COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) AS prefix_5,
  COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) AS prefix_10,
  COUNT(DISTINCT LEFT(email, 15)) / COUNT(*) AS prefix_15,
  COUNT(DISTINCT LEFT(email, 20)) / COUNT(*) AS prefix_20
FROM users;
```
**输出**：  
```
+-----------+------------+------------+------------+
| prefix_5  | prefix_10  | prefix_15  | prefix_20  |
+-----------+------------+------------+------------+
| 0.4021    | 0.8734     | 0.9805     | 0.9912     |
+-----------+------------+------------+------------+
```
**分析**：  
- 前缀长度从 5 到 10 时，选择性从 40.21% 提升至 87.34%，**显著增长**。  
- 长度从 15 到 20 时，选择性从 98.05% 提升至 99.12%，**接近完整列选择性**。  

**结论**：选择 **15 个字符** 作为前缀（选择性 98.05% vs 完整 99.23%），在存储和性能间取得平衡。

---

##### **3. 验证最常见值的前缀冲突**
**步骤**：  
- 列出完整列的最常见值及其前缀，检查是否可能重复。  

**示例**：  
```sql
-- 统计完整列最常见值
SELECT 
  email, 
  COUNT(*) AS cnt 
FROM users 
GROUP BY email 
ORDER BY cnt DESC 
LIMIT 5;

-- 统计前缀最常见值（假设前缀长度=15）
SELECT 
  LEFT(email, 15) AS prefix, 
  COUNT(*) AS cnt 
FROM users 
GROUP BY prefix 
ORDER BY cnt DESC 
LIMIT 5;
```
**输出对比**：  
| 完整列值                  | 出现次数 | 前缀（15字符）    | 出现次数 |
|---------------------------|----------|-------------------|----------|
| alice@example


