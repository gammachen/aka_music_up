### 分表时机与考量维度

#### **1. 分表的数据量参考阈值**
分表的触发数据量并非固定，需结合存储引擎、硬件及业务场景综合评估：

- **经验参考范围**：
  - **OLTP 场景**：单表行数超过 **500万~2000万**（假设单行约1KB）
  - **OLAP 场景**：单表数据量超过 **100GB~1TB**
  
- **计算公式**：
  ```text
  临界数据量 = 可用存储资源 / (单行大小 × 预期增长率 × 业务周期)
  ```
  **示例**：  
  若服务器磁盘为 1TB，单行大小 2KB，业务计划运行 3 年，年均增长 1000 万行：  
  `临界数据量 = 1TB / (2KB × 10,000,000 × 3) ≈ 16,666 行`（显然此公式需结合实际情况调整）

#### **2. 分表的核心考量维度**

| 维度             | 说明                                                                 | 示例场景                                                                 |
|------------------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| **查询性能**     | 响应时间超过 SLA（如 >500ms）或 QPS 下降 30%                          | 用户订单表按 `user_id` 分表，避免全表扫描                                |
| **写入吞吐**     | 插入/更新延迟显著增加或出现锁竞争                                    | 日志表按时间分表，分散写入热点                                          |
| **存储瓶颈**     | 单表文件超过存储系统优化阈值（如 InnoDB 单表建议 <2TB）               | 监控数据按月度分表，每个分表 200GB                                      |
| **管理复杂度**   | 备份耗时 >4 小时或索引维护影响业务                                   | 电商商品表按类目分表，独立维护                                          |
| **业务扩展性**   | 需支持多租户或地域隔离                                               | SaaS 用户数据按 `tenant_id` 分表                                        |

---

### B+树层数与检索效率分析

#### **1. B+树层数计算模型**
假设 InnoDB 存储引擎配置：
- **页大小**：16KB
- **主键类型**：BIGINT（8字节）
- **指针大小**：6字节

**单页索引条目数**：
```text
entries_per_page = (页大小 - 页头) / (主键大小 + 指针大小) 
≈ (16384 - 128) / (8 + 6) ≈ 1120
```

**各层级数据量**：
- **层数** | **最大记录数**  
  - 1 层：1120  
  - 2 层：1120 × 1120 ≈ **125万**  
  - 3 层：1120³ ≈ **14亿**  
  - 4 层：1120⁴ ≈ **1.6万亿**

#### **2. 层数对查询效率的影响**

- **HDD 场景**：
  ```text
  查询时间 ≈ 寻道时间 × 层数 + 传输时间
  假设寻道时间 10ms：
  - 3 层：10ms × 3 = 30ms
  - 4 层：10ms × 4 = 40ms
  ```
  
- **SSD 场景**：
  ```text
  随机读延迟 0.1ms：
  - 3 层：0.3ms
  - 4 层：0.4ms
  ```

**关键结论**：  
- 在 HDD 上，层数增加会导致显著延迟（每层+10ms）  
- 对 SSD，层数增加影响较小，但超高并发时仍需关注  

---

### 综合决策矩阵

| 数据规模         | 存储类型 | 典型处理方案                          | 性能优化重点                     |
|------------------|----------|---------------------------------------|----------------------------------|
| < 500万行        | HDD/SSD  | 单表 + 复合索引                       | 优化查询语句，减少回表           |
| 500万~5亿行      | SSD      | 分区表 + 索引下推                    | 利用覆盖索引，减少 IO            |
| >5亿行           | NVMe SSD | 分库分表 + 分布式索引                 | 数据本地化，避免跨节点查询       |
| >100亿行         | 分布式存储| 列式存储 + 块级元数据                | 向量化处理，跳过无关数据块       |

---

### 实战案例

**案例1：电商订单表分表**  
- **背景**：订单表达 8 亿行，核心查询 `SELECT * FROM orders WHERE user_id=? AND status='paid'`  
- **方案**：  
  ```sql
  -- 按 user_id 哈希分 1024 个表
  CREATE TABLE orders_0000 LIKE orders;
  ...
  CREATE TABLE orders_1023 LIKE orders;
  ```
- **效果**：  
  - 单表数据量降至 78 万行  
  - 查询延迟从 1200ms 降至 8ms  

**案例2：物联网时序数据分区**  
- **背景**：设备日志每天新增 1 亿条，需查询最近 7 天数据  
- **方案**：  
  ```sql
  CREATE TABLE sensor_data (
    ts TIMESTAMP, 
    device_id INT,
    value FLOAT
  ) PARTITION BY RANGE (TO_DAYS(ts)) (
    PARTITION p202309 VALUES LESS THAN (TO_DAYS('2023-10-01')),
    PARTITION p202310 VALUES LESS THAN (TO_DAYS('2023-11-01'))
  );
  ```
- **效果**：  
  - 每日自动归档旧分区至冷存储  
  - 查询扫描数据量减少 90%  

---

### 总结建议

1. **分表触发指标**：  
   - 当单表数据量导致 **查询 P95 延迟 > 业务容忍阈值** 或 **存储空间增长速率超过硬件扩容能力** 时应分表

2. **B+树层数优化**：  
   - 对 HDD 存储，尽量控制树高 ≤3 层（对应约 14 亿行）  
   - 对 SSD/NVMe，可接受更高树高，但需监控 IOPS 使用率

3. **混合架构趋势**：  
   - 现代云数据库（如 Aurora、PolarDB）通过 **日志即数据**、**智能分层存储** 等技术，自动优化底层存储结构，降低人工分表需求

