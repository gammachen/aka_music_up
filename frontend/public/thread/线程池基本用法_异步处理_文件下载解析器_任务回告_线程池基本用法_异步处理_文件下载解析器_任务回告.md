### 升级功能说明
1. **任务结果回告**：每个任务解析完成后生成 JSON 格式的回告数据。
2. **汇总统计**：主线程等待所有任务完成，统计成功、失败、被拒绝的任务数量。
3. **邮件通知**：模拟汇总完成后发送邮件通知用户。

---

### 完整代码实现
```java
import java.util.concurrent.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class EnhancedFileDownloadService {

    // 线程池配置
    private static final ThreadPoolExecutor executor = new ThreadPoolExecutor(
        2, 3, 60, TimeUnit.SECONDS,
        new ArrayBlockingQueue<>(2),
        new RejectedExecutionHandler() {
            @Override
            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                // 记录被拒绝的任务
                synchronized (rejectedTasks) {
                    rejectedTasks.add(((DownloadTask) r).getUrl());
                }
                System.err.println("[拒绝] 任务过多，无法处理: " + ((DownloadTask) r).getUrl());
            }
        }
    );

    // 存储所有任务的 Future 对象（用于获取结果）
    private static final List<Future<FileReport>> futures = new CopyOnWriteArrayList<>();
    // 存储被拒绝的任务 URL
    private static final List<String> rejectedTasks = new CopyOnWriteArrayList<>();

    public static void main(String[] args) {
        String[] urls = { /* 同上 */ };

        // 提交任务
        for (String url : urls) {
            DownloadTask task = new DownloadTask(url);
            try {
                Future<FileReport> future = executor.submit(task); // 提交 Callable 任务
                futures.add(future);
                System.out.printf("[提交成功] %s (队列大小: %d)\n", url, executor.getQueue().size());
            } catch (RejectedExecutionException e) {
                rejectedTasks.add(url);
                System.err.printf("[提交失败] %s\n", url);
            }
            try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); }
        }

        // 等待所有任务完成
        executor.shutdown();
        try {
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }

        // 汇总任务结果
        List<FileReport> reports = new ArrayList<>();
        AtomicInteger successCount = new AtomicInteger();
        AtomicInteger failureCount = new AtomicInteger();

        for (Future<FileReport> future : futures) {
            try {
                FileReport report = future.get(); // 阻塞获取结果
                reports.add(report);
                successCount.incrementAndGet();
            } catch (Exception e) {
                failureCount.incrementAndGet();
            }
        }

        // 生成汇总报告
        String summary = String.format(
            "任务汇总:\n- 成功: %d\n- 失败: %d\n- 被拒绝: %d\n- 总文件大小: %d KB",
            successCount.get(), failureCount.get(), rejectedTasks.size(),
            reports.stream().mapToInt(r -> r.fileSize).sum()
        );

        // 模拟发送邮件通知
        sendEmailNotification(summary, reports);
    }

    // 模拟邮件通知
    private static void sendEmailNotification(String summary, List<FileReport> reports) {
        System.out.println("\n=== 邮件通知 ===");
        System.out.println(summary);
        System.out.println("详细报告:");
        reports.forEach(report -> System.out.println(report.toJson()));
        System.out.println("================\n");
    }

    // 文件下载任务（改为 Callable 以返回结果）
    static class DownloadTask implements Callable<FileReport> {
        private final String url;
        private final Random random = new Random();

        public DownloadTask(String url) {
            this.url = url;
        }

        public String getUrl() {
            return url;
        }

        @Override
        public FileReport call() throws Exception {
            try {
                // 模拟下载（0.5~2秒）
                Thread.sleep(500 + random.nextInt(1500));

                // 解析文件元数据
                String fileType = url.substring(url.lastIndexOf('.') + 1);
                int fileSize = 100 + random.nextInt(900); // 模拟文件大小 100~1000 KB
                String content = switch (fileType) {      // 模拟文件内容
                    case "zip" -> "[ZIP] Compressed data";
                    case "pdf" -> "[PDF] Document pages: " + (1 + random.nextInt(50));
                    default -> "[TEXT] Sample content";
                };

                // 返回解析结果
                return new FileReport(url, fileType, fileSize, content);
            } catch (Exception e) {
                System.err.printf("[任务失败] %s (%s)\n", url, e.getMessage());
                throw e; // 抛出异常以便 Future.get() 捕获
            }
        }
    }

    // 文件回告数据结构
    static class FileReport {
        String url;
        String fileType;
        int fileSize;
        String content;

        public FileReport(String url, String fileType, int fileSize, String content) {
            this.url = url;
            this.fileType = fileType;
            this.fileSize = fileSize;
            this.content = content;
        }

        public String toJson() {
            return String.format(
                "{ \"url\": \"%s\", \"type\": \"%s\", \"size\": %d, \"content\": \"%s\" }",
                url, fileType, fileSize, content
            );
        }
    }
}
```

---

### 关键升级点解析

#### 1. 任务结果回告
- **`FileReport` 类**：封装文件类型、大小、模拟内容，并提供 `toJson()` 方法生成 JSON 格式数据。
- **`Callable` 接口**：将 `DownloadTask` 改为 `Callable<FileReport>`，在 `call()` 方法中返回解析结果。
- **Future 收集**：通过 `executor.submit(task)` 提交任务并获取 `Future` 对象，存储所有 Future 用于后续结果汇总。

#### 2. 线程安全与数据统计
- **并发容器**：使用 `CopyOnWriteArrayList` 存储 `futures` 和 `rejectedTasks`，避免多线程竞争。
- **原子计数器**：通过 `AtomicInteger` 统计成功/失败任务数量。
- **异常处理**：在 `future.get()` 时捕获异常，区分任务成功与失败。

#### 3. 邮件通知与汇总
- **结果聚合**：主线程等待线程池关闭后，遍历所有 `Future` 对象获取结果，计算总文件大小。
- **邮件模拟**：输出汇总统计和每个任务的 JSON 报告，模拟发送邮件。

---

### 执行输出示例
```plaintext
[提交成功] http://file1.zip (队列大小: 0)
[提交成功] http://file2.pdf (队列大小: 0)
[提交成功] http://file3.jpg (队列大小: 1)
[提交成功] http://file4.mp4 (队列大小: 2)
[拒绝] 任务过多，无法处理: http://file5.doc
[提交失败] http://file5.doc
[拒绝] 任务过多，无法处理: http://file6.png
[提交失败] http://file6.png

=== 邮件通知 ===
任务汇总:
- 成功: 4
- 失败: 0
- 被拒绝: 2
- 总文件大小: 2800 KB
详细报告:
{ "url": "http://file1.zip", "type": "zip", "size": 450, "content": "[ZIP] Compressed data" }
{ "url": "http://file2.pdf", "type": "pdf", "size": 780, "content": "[PDF] Document pages: 32" }
...
================
```

---

### 设计优化
- **结果扩展性**：`FileReport` 可添加更多字段（如 MD5 校验、下载耗时）。
- **异步回调**：结合 `CompletableFuture` 实现下载完成后自动触发解析逻辑。
- **重试机制**：对被拒绝或失败的任务，可将其加入重试队列重新提交。

此案例完整展示了线程池在真实场景中的高级用法，包括任务结果处理、资源统计和系统间通知，可直接应用于实际项目开发。