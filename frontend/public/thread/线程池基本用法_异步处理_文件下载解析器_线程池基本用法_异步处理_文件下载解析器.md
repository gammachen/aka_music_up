以下是一个基于 **文件批量下载与处理** 的线程池真实案例，模拟多线程下载文件、解析内容，并在高并发时触发拒绝策略的场景。代码包含线程池配置、任务队列管理、拒绝策略处理以及资源释放逻辑。

---

### 真实场景描述
假设需要开发一个文件下载服务，用户可批量提交文件 URL，线程池异步下载文件并解析内容。当瞬时提交任务过多时，需触发拒绝策略，记录失败任务。

---

### 代码实现
```java
import java.util.concurrent.*;
import java.util.Random;

public class FileDownloadService {
    // 线程池配置：核心线程2，最大线程3，队列容量2，拒绝策略记录失败任务
    private static final ThreadPoolExecutor executor = new ThreadPoolExecutor(
        2, 
        3, 
        60, TimeUnit.SECONDS,
        new ArrayBlockingQueue<>(2),
        new RejectedExecutionHandler() {
            @Override
            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                // 记录被拒绝的任务（实际可持久化到数据库或日志）
                System.err.println("[拒绝] 任务过多，无法处理: " + ((DownloadTask) r).getUrl());
            }
        }
    );

    public static void main(String[] args) {
        // 模拟用户批量提交文件下载请求（共6个任务，每秒提交2个）
        String[] urls = {
            "http://file1.zip",
            "http://file2.pdf",
            "http://file3.jpg",
            "http://file4.mp4",
            "http://file5.doc",
            "http://file6.png"
        };

        for (int i = 0; i < urls.length; i++) {
            DownloadTask task = new DownloadTask(urls[i]);
            try {
                executor.execute(task);
                System.out.printf("[提交成功] %s (当前队列大小: %d)\n", 
                    task.getUrl(), executor.getQueue().size());
            } catch (RejectedExecutionException e) {
                System.err.printf("[提交失败] %s 被拒绝\n", task.getUrl());
            }
            // 模拟用户每秒提交2次（间隔500ms）
            try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); }
        }

        // 优雅关闭线程池
        executor.shutdown();
        try {
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
    }

    // 文件下载任务（模拟真实处理逻辑）
    static class DownloadTask implements Runnable {
        private final String url;
        private final Random random = new Random();

        public DownloadTask(String url) {
            this.url = url;
        }

        public String getUrl() {
            return url;
        }

        @Override
        public void run() {
            try {
                // 模拟下载耗时（0.5~2秒）
                System.out.printf("[开始下载] %s (线程: %s)\n", 
                    url, Thread.currentThread().getName());
                int delay = 500 + random.nextInt(1500);
                Thread.sleep(delay);

                // 模拟解析文件内容（实际可能是解析PDF、图片处理等）
                System.out.printf("[完成下载] %s (耗时: %dms)\n", url, delay);
            } catch (InterruptedException e) {
                System.err.printf("[任务中断] %s\n", url);
            }
        }
    }
}
```

---

### 执行流程分析
1. **任务提交**：
   - **任务1、2**：直接由核心线程处理，队列为空。
   - **任务3、4**：进入队列（容量2），此时队列满。
   - **任务5**：队列已满，创建第三个线程（最大线程数3）处理。
   - **任务6**：线程和队列均满，触发拒绝策略。

2. **输出示例**：
   ```
   [提交成功] http://file1.zip (当前队列大小: 0)
   [提交成功] http://file2.pdf (当前队列大小: 0)
   [开始下载] http://file1.zip (线程: pool-1-thread-1)
   [开始下载] http://file2.pdf (线程: pool-1-thread-2)
   [提交成功] http://file3.jpg (当前队列大小: 1)
   [提交成功] http://file4.mp4 (当前队列大小: 2)
   [提交成功] http://file5.doc (当前队列大小: 2)
   [开始下载] http://file5.doc (线程: pool-1-thread-3)  // 第3个线程被创建
   [拒绝] 任务过多，无法处理: http://file6.png         // 第6个任务被拒绝
   [完成下载] http://file1.zip (耗时: 856ms)
   [开始下载] http://file3.jpg (线程: pool-1-thread-1) // 核心线程复用
   ```

---

### 关键设计点
1. **线程池参数调优**：
   - **核心线程数**：根据服务器 CPU 核心数设定（如 `Runtime.getRuntime().availableProcessors()`）。
   - **队列类型**：使用 `ArrayBlockingQueue` 控制队列长度，避免内存溢出。
   - **拒绝策略**：记录失败任务，后续可重试或通知用户。

2. **真实场景扩展**：
   - 使用 `Future` 获取任务结果，例如返回下载后的文件路径。
   - 结合 `CompletableFuture` 实现异步回调，例如下载完成后自动解析。
   - 监控线程池状态（如 `executor.getActiveCount()`）实现动态扩容。

3. **资源管理**：
   - 通过 `shutdown()` 和 `awaitTermination()` 确保所有任务完成后再关闭服务。
   - 处理线程中断（如 `Thread.sleep()` 响应 `InterruptedException`）。

---

### 典型应用场景
- **Web 服务器**：处理 HTTP 请求，限制并发连接数。
- **大数据处理**：批量处理日志文件、ETL 任务。
- **异步通知**：发送短信、邮件等后台任务。

通过此案例，可以直观理解线程池如何在高并发场景中平衡资源利用与系统稳定性。